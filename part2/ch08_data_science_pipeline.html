
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Chapter 8: Data-Science Pipeline in Python &#8212; The Neuroscience of AI</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'part2/ch08_data_science_pipeline';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="canonical" href="https://neuroai-handbook.github.io/part2/ch08_data_science_pipeline.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Chapter 9: Classical Machine-Learning Foundations" href="../part3/ch09_ml_foundations.html" />
    <link rel="prev" title="Chapter 7: Information Theory Essentials" href="ch07_information_theory.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nai.png" class="logo__image only-light" alt="The Neuroscience of AI - Home"/>
    <script>document.write(`<img src="../_static/nai.png" class="logo__image only-dark" alt="The Neuroscience of AI - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    The Neuroscience of AI
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Part I · Brains &amp; Inspiration</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../part1/ch01_intro.html">Chapter 1: Introduction to Neuroscience ↔ AI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part1/ch02_neuro_foundations.html">Chapter 2: Neuroscience Foundations for AI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part1/ch03_spatial_navigation.html">Chapter 3: Spatial Navigation – Place &amp; Grid Cells</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part1/ch04_perception_pipeline.html">Chapter 4: Perception Pipeline – Visual Cortex → CNNs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part II · Brains Meet Math &amp; Data</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ch05_brain_networks.html">Chapter 5: Default-Mode vs Executive Control Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch06_neurostimulation.html">Chapter 6: Neurostimulation &amp; Plasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch07_information_theory.html">Chapter 7: Information Theory Essentials</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 8: Data-Science Pipeline in Python</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part III · Learning Machines</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../part3/ch09_ml_foundations.html">Chapter 9: Classical Machine-Learning Foundations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part3/ch10_deep_learning.html">Chapter 10: Deep Learning: Training &amp; Optimisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part3/ch11_sequence_models.html">Chapter 11: Sequence Models: RNN → Attention → Transformer</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part IV · Frontier Models</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../part4/ch12_large_language_models.html">Chapter 12: Large Language Models &amp; Fine-Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part4/ch13_multimodal_models.html">Chapter 13: Multimodal &amp; Diffusion Models</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part V · Ethics &amp; Futures</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../part5/ch15_ethical_ai.html">Chapter 15: Ethical AI - Considerations for NeuroAI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part5/ch16_future_directions.html">Chapter 16: Where Next for Neuro-AI?</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Part VI · Advanced Applications</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../part6/ch17_bci_human_ai_interfaces.html">Brain-Computer Interfaces and Human-AI Interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part6/ch18_neuromorphic_computing.html">Chapter 18: Neuromorphic Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part6/ch19_cognitive_neuro_dl.html">Cognitive Neuroscience and Deep Learning</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../part6/ch20_case_studies.html">Case Studies in NeuroAI</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../part6/ch20_interactive.html">Interactive NeuroAI Case Studies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../part6/jupyter_ai_demo.html">AI-Assisted Learning with Jupyter AI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../part6/rise_slides_demo.html">Creating Presentations with RISE</a></li>


</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../part6/ch21_ai_for_neuro_discovery.html">Chapter 21: AI for Neuroscience Discovery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part6/ch22_embodied_ai_robotics.html">Chapter 22: Embodied AI and Robotics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part6/ch24_quantum_computing_neuroai.html">Chapter 24: Quantum Computing and NeuroAI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../part6/ch23_lifelong_learning.html">Chapter 23: Lifelong Learning</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendices/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendices/math_python_refresher.html">Appendix A: Math &amp; Python Mini-Refresher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendices/dataset_catalogue.html">Appendix B: Dataset Catalogue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendices/colab_setup.html">Appendix C: Google Colab Setup for NeuroAI</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/edit/master/docs/part2/ch08_data_science_pipeline.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fpart2/ch08_data_science_pipeline.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/part2/ch08_data_science_pipeline.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 8: Data-Science Pipeline in Python</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chapter-goals">8.0 Chapter Goals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#neural-data-types-sources">8.1 Neural Data Types &amp; Sources</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spike-trains-and-local-field-potentials-lfps">8.1.1 Spike Trains and Local Field Potentials (LFPs)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eeg-meg-and-fmri-data">8.1.2 EEG, MEG, and fMRI Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calcium-imaging">8.1.3 Calcium Imaging</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#behavioral-measurements">8.1.4 Behavioral Measurements</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#data-preprocessing">8.2 Data Preprocessing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#filtering-and-artifact-removal">8.2.1 Filtering and Artifact Removal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensionality-reduction-techniques">8.2.2 Dimensionality Reduction Techniques</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-extraction">8.2.3 Feature Extraction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#normalization-approaches">8.2.4 Normalization Approaches</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exploratory-analysis">8.3 Exploratory Analysis</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#descriptive-statistics-for-neural-data">8.3.1 Descriptive Statistics for Neural Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization-techniques">8.3.2 Visualization Techniques</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensionality-reduction-and-visualization">8.3.3 Dimensionality Reduction and Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-frequency-analysis">8.3.4 Time-Frequency Analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#statistical-modeling">8.4 Statistical Modeling</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalized-linear-models-for-neural-data">8.4.1 Generalized Linear Models for Neural Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#point-process-models-for-spike-trains">8.4.2 Point Process Models for Spike Trains</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bayesian-approaches">8.4.3 Bayesian Approaches</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model-validation-techniques">8.4.4 Model Validation Techniques</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#machine-learning-applications">8.5 Machine Learning Applications</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#supervised-learning-for-neural-decoding">8.5.1 Supervised Learning for Neural Decoding</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unsupervised-learning-for-pattern-discovery">8.5.2 Unsupervised Learning for Pattern Discovery</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deep-learning-approaches-for-neural-data">8.5.3 Deep Learning Approaches for Neural Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transfer-learning-and-domain-adaptation">8.5.4 Transfer Learning and Domain Adaptation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#code-lab-building-an-end-to-end-pipeline">8.6 Code Lab: Building an End-to-End Pipeline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-art-of-programming-for-neuroscience-data">8.7 The Art of Programming for Neuroscience Data</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-python-for-neural-data-analysis">8.7.1 Why Python for Neural Data Analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-code-to-concept-programming-as-scientific-thinking">8.7.2 From Code to Concept: Programming as Scientific Thinking</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-future-of-neural-data-science-ai-augmented-programming">8.7.3 The Future of Neural Data Science: AI-Augmented Programming</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#best-practices-for-the-ai-assisted-neuroscience-era">8.7.4 Best Practices for the AI-Assisted Neuroscience Era</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#take-aways">8.8 Take-aways</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading-media">8.9 Further Reading &amp; Media</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#neuroscience-data-analysis">Neuroscience Data Analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#python-for-scientific-computing">Python for Scientific Computing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ai-augmented-programming">AI-Augmented Programming</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#future-of-neuroscience-and-ai">Future of Neuroscience and AI</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recommended-tools-and-libraries">Recommended Tools and Libraries</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Neuroscience Data Analysis</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ai-assisted-programming">AI-Assisted Programming</a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-8-data-science-pipeline-in-python">
<h1>Chapter 8: Data-Science Pipeline in Python<a class="headerlink" href="#chapter-8-data-science-pipeline-in-python" title="Link to this heading">#</a></h1>
<section id="chapter-goals">
<h2>8.0 Chapter Goals<a class="headerlink" href="#chapter-goals" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Master the data science workflow for neuroscience applications</p></li>
<li><p>Implement robust preprocessing, analysis, visualization, and modeling techniques</p></li>
<li><p>Work with real neural datasets through practical examples</p></li>
<li><p>Create reproducible analysis pipelines for neuroscience experiments</p></li>
</ul>
</section>
<section id="neural-data-types-sources">
<h2>8.1 Neural Data Types &amp; Sources<a class="headerlink" href="#neural-data-types-sources" title="Link to this heading">#</a></h2>
<p><img alt="Neural Data Science Pipeline" src="../_images/neural_data_pipeline.svg" />
<em>Figure 8.1: The data science pipeline for neural data, showing the progression from data acquisition through processing, analysis, and interpretation.</em></p>
<p>Neural data comes in many forms, each requiring specialized processing approaches.</p>
<section id="spike-trains-and-local-field-potentials-lfps">
<h3>8.1.1 Spike Trains and Local Field Potentials (LFPs)<a class="headerlink" href="#spike-trains-and-local-field-potentials-lfps" title="Link to this heading">#</a></h3>
<p>Spike trains represent the precise timing of action potentials from individual neurons, while LFPs reflect the summed electrical activity of local neural populations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>

<span class="c1"># Simulating spike train data</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_spike_train</span><span class="p">(</span><span class="n">firing_rate</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a simulated spike train with Poisson statistics.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        firing_rate: Average firing rate in Hz</span>
<span class="sd">        duration: Recording duration in seconds</span>
<span class="sd">        dt: Time bin size in seconds</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        times: Array of spike times</span>
<span class="sd">        binary_spikes: Binary array with 1s indicating spikes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">binary_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">firing_rate</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">binary_spikes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
    
    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">binary_spikes</span>

<span class="c1"># Simulating LFP data</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_lfp</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span> <span class="n">amplitudes</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate simulated LFP data with specified oscillatory components.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        duration: Recording duration in seconds</span>
<span class="sd">        dt: Time bin size in seconds</span>
<span class="sd">        frequencies: List of frequency components to include (Hz)</span>
<span class="sd">        amplitudes: Amplitudes for each frequency component</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        time: Time points</span>
<span class="sd">        lfp: LFP signal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    
    <span class="n">lfp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">freq</span><span class="p">,</span> <span class="n">amp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">):</span>
        <span class="n">lfp</span> <span class="o">+=</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span>
    
    <span class="c1"># Add some noise</span>
    <span class="n">lfp</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">lfp</span>

<span class="c1"># Visualize spike train and LFP</span>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_neural_data</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
    <span class="n">spike_times</span><span class="p">,</span> <span class="n">binary_spikes</span> <span class="o">=</span> <span class="n">simulate_spike_train</span><span class="p">(</span>
        <span class="n">firing_rate</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">time</span><span class="p">,</span> <span class="n">lfp</span> <span class="o">=</span> <span class="n">simulate_lfp</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Plot spike train raster</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eventplot</span><span class="p">([</span><span class="n">spike_times</span><span class="p">],</span> <span class="n">lineoffsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">])</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Spike Train&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
    
    <span class="c1"># Plot LFP</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">lfp</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (μV)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Local Field Potential&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span>
</pre></div>
</div>
</section>
<section id="eeg-meg-and-fmri-data">
<h3>8.1.2 EEG, MEG, and fMRI Data<a class="headerlink" href="#eeg-meg-and-fmri-data" title="Link to this heading">#</a></h3>
<p>These non-invasive recording techniques offer different spatial and temporal resolutions:</p>
<ul class="simple">
<li><p><strong>EEG (Electroencephalography)</strong>: High temporal resolution (milliseconds), limited spatial resolution</p></li>
<li><p><strong>MEG (Magnetoencephalography)</strong>: Similar to EEG but with improved spatial resolution</p></li>
<li><p><strong>fMRI (functional Magnetic Resonance Imaging)</strong>: Excellent spatial resolution (millimeters), poor temporal resolution (seconds)</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">load_and_preprocess_eeg</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example function to load and preprocess EEG data.</span>
<span class="sd">    In practice, you would use libraries like MNE for this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In actual implementation, replace with:</span>
    <span class="c1"># import mne</span>
    <span class="c1"># raw = mne.io.read_raw_fif(filename, preload=True)</span>
    <span class="c1"># raw.filter(1, 40)  # Bandpass filter between 1-40 Hz</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For EEG data, typical preprocessing includes:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. Loading data (MNE Python)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2. Filtering (typically bandpass between 1-40 Hz)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3. Artifact rejection/correction (ICA for eye movements)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;4. Epoching around events of interest&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;5. Baseline correction&quot;</span><span class="p">)</span>
    
    <span class="c1"># Simulate some preprocessed data</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="n">n_times</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_times</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    
    <span class="c1"># Add some alpha oscillations (8-12 Hz)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_times</span><span class="p">)</span> <span class="o">/</span> <span class="mf">250.0</span>  <span class="c1"># Assuming 250 Hz sampling rate</span>
    <span class="n">alpha_oscillation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">times</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">alpha_oscillation</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># Add to first few channels</span>
    
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">times</span>
</pre></div>
</div>
</section>
<section id="calcium-imaging">
<h3>8.1.3 Calcium Imaging<a class="headerlink" href="#calcium-imaging" title="Link to this heading">#</a></h3>
<p>Calcium imaging measures intracellular calcium concentration changes as a proxy for neural activity.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_calcium_data</span><span class="p">(</span><span class="n">raw_fluorescence</span><span class="p">,</span> <span class="n">frame_rate</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic processing for calcium imaging data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        raw_fluorescence: Matrix where rows are neurons and columns are frames</span>
<span class="sd">        frame_rate: Imaging frame rate in Hz</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        df_f: Delta F / F</span>
<span class="sd">        activity: Deconvolved neural activity estimate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_neurons</span><span class="p">,</span> <span class="n">n_frames</span> <span class="o">=</span> <span class="n">raw_fluorescence</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>
    
    <span class="c1"># Calculate baseline (F0) as the 10th percentile over a sliding window</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_rate</span> <span class="o">*</span> <span class="mi">30</span><span class="p">)</span>  <span class="c1"># 30 seconds window</span>
    <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">raw_fluorescence</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">baseline</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">raw_fluorescence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
    
    <span class="c1"># Calculate ΔF/F</span>
    <span class="n">df_f</span> <span class="o">=</span> <span class="p">(</span><span class="n">raw_fluorescence</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">)</span> <span class="o">/</span> <span class="n">baseline</span>
    
    <span class="c1"># In real applications, you would deconvolve to estimate spike rates</span>
    <span class="c1"># Here, we use a simple threshold-based approach</span>
    <span class="n">activity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">df_f</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
        <span class="c1"># Detect calcium transients using a simple threshold</span>
        <span class="n">activity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span>
            <span class="p">(</span><span class="n">df_f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">df_f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="o">/</span> <span class="mi">7</span><span class="p">),</span>  <span class="c1"># Exponential kernel</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df_f</span><span class="p">,</span> <span class="n">activity</span>
</pre></div>
</div>
</section>
<section id="behavioral-measurements">
<h3>8.1.4 Behavioral Measurements<a class="headerlink" href="#behavioral-measurements" title="Link to this heading">#</a></h3>
<p>Integrating neural activity with behavior is crucial for understanding neural function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">correlate_neural_behavioral_data</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">,</span> <span class="n">behavior</span><span class="p">,</span> <span class="n">lag_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute cross-correlation between neural activity and behavioral measurements.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        neural_activity: Neural activity time series</span>
<span class="sd">        behavior: Behavioral measurement time series</span>
<span class="sd">        lag_range: Range of lags to compute in ms</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        lags: Array of lag times in ms</span>
<span class="sd">        cross_corr: Cross-correlation values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure inputs are standardized</span>
    <span class="n">neural_activity</span> <span class="o">=</span> <span class="p">(</span><span class="n">neural_activity</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">)</span>
    <span class="n">behavior</span> <span class="o">=</span> <span class="p">(</span><span class="n">behavior</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">behavior</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">behavior</span><span class="p">)</span>
    
    <span class="c1"># Compute cross-correlation</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lag_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lag_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">cross_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">lag</span><span class="p">):</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">)</span><span class="o">-</span><span class="n">lag</span><span class="p">)],</span>
                   <span class="n">behavior</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lag</span><span class="p">):</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">behavior</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">behavior</span><span class="p">)</span><span class="o">+</span><span class="n">lag</span><span class="p">)])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">lags</span>
    <span class="p">])</span>
    
    <span class="k">return</span> <span class="n">lags</span><span class="p">,</span> <span class="n">cross_corr</span>
</pre></div>
</div>
</section>
</section>
<section id="data-preprocessing">
<h2>8.2 Data Preprocessing<a class="headerlink" href="#data-preprocessing" title="Link to this heading">#</a></h2>
<p>Proper preprocessing is critical for reliable results.</p>
<section id="filtering-and-artifact-removal">
<h3>8.2.1 Filtering and Artifact Removal<a class="headerlink" href="#filtering-and-artifact-removal" title="Link to this heading">#</a></h3>
<p>Signal filtering removes noise and isolates frequency bands of interest.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">preprocess_neural_signal</span><span class="p">(</span><span class="n">signal_data</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> 
                             <span class="n">notch_freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply common preprocessing steps to neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal_data: Raw neural signal</span>
<span class="sd">        sampling_rate: Sampling rate in Hz</span>
<span class="sd">        notch_freq: Frequency to remove (e.g., 60 Hz line noise)</span>
<span class="sd">        bandpass: Tuple of (low, high) frequencies for bandpass filter</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        filtered_signal: Preprocessed signal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span> <span class="k">as</span> <span class="n">sp_signal</span>
    
    <span class="c1"># Apply notch filter to remove line noise</span>
    <span class="n">notch_b</span><span class="p">,</span> <span class="n">notch_a</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">iirnotch</span><span class="p">(</span><span class="n">notch_freq</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">notch_filtered</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">notch_b</span><span class="p">,</span> <span class="n">notch_a</span><span class="p">,</span> <span class="n">signal_data</span><span class="p">)</span>
    
    <span class="c1"># Apply bandpass filter</span>
    <span class="n">nyquist</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sampling_rate</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">bandpass</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">low</span><span class="o">/</span><span class="n">nyquist</span><span class="p">,</span> <span class="n">high</span><span class="o">/</span><span class="n">nyquist</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">bandpass_filtered</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">notch_filtered</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">bandpass_filtered</span>

<span class="k">def</span><span class="w"> </span><span class="nf">detect_artifacts</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect artifacts in neural data using amplitude thresholding.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal: Neural signal</span>
<span class="sd">        threshold: Number of standard deviations for threshold</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        artifact_indices: Indices where artifacts were detected</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signal_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">artifact_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">signal_std</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Expand artifact regions by 100 samples in each direction</span>
    <span class="n">expanded_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">artifact_indices</span><span class="p">:</span>
        <span class="n">expanded_indices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="o">-</span><span class="mi">100</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">idx</span><span class="o">+</span><span class="mi">100</span><span class="p">)))</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">expanded_indices</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="dimensionality-reduction-techniques">
<h3>8.2.2 Dimensionality Reduction Techniques<a class="headerlink" href="#dimensionality-reduction-techniques" title="Link to this heading">#</a></h3>
<p>Neural datasets often have high dimensionality, requiring techniques to extract meaningful structure.</p>
<p><img alt="Dimensionality Reduction Techniques" src="../_images/dimensionality_reduction.svg" />
<em>Figure 8.2: Comparison of dimensionality reduction techniques for neural data, showing how high-dimensional data can be projected into lower-dimensional spaces using PCA, t-SNE, and UMAP.</em></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_dimensionality_reduction</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pca&#39;</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply dimensionality reduction to neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        data: Neural data array (samples × features)</span>
<span class="sd">        method: Dimensionality reduction method (&#39;pca&#39;, &#39;tsne&#39;, or &#39;umap&#39;)</span>
<span class="sd">        n_components: Number of dimensions in output</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        reduced_data: Data in reduced dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.manifold</span><span class="w"> </span><span class="kn">import</span> <span class="n">TSNE</span>
    
    <span class="c1"># Standardize data</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
    <span class="n">scaled_data</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pca&#39;</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">)</span>
        <span class="n">reduced_data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>
        <span class="n">explained_variance</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">explained_variance_ratio_</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Explained variance: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">explained_variance</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;tsne&#39;</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">reduced_data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;umap&#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">umap</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">)</span>
            <span class="n">reduced_data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UMAP not installed. Install with: pip install umap-learn&quot;</span><span class="p">)</span>
            <span class="n">reduced_data</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">return</span> <span class="n">reduced_data</span>
</pre></div>
</div>
</section>
<section id="feature-extraction">
<h3>8.2.3 Feature Extraction<a class="headerlink" href="#feature-extraction" title="Link to this heading">#</a></h3>
<p>Extract meaningful features from raw neural data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">extract_frequency_features</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> 
                              <span class="n">freq_bands</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">)]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract frequency band features from neural signal.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal: Neural time series</span>
<span class="sd">        sampling_rate: Sampling rate in Hz</span>
<span class="sd">        freq_bands: List of frequency bands to extract (delta, theta, alpha, beta, gamma)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        band_powers: Dictionary of power in each frequency band</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span> <span class="k">as</span> <span class="n">sp_signal</span>
    
    <span class="c1"># Compute power spectral density</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    
    <span class="c1"># Calculate power in each frequency band</span>
    <span class="n">band_powers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">band_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">band_names</span><span class="p">,</span> <span class="n">freq_bands</span><span class="p">):</span>
        <span class="c1"># Find frequency indices within the band</span>
        <span class="n">idx_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="n">low</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span>
        <span class="c1"># Calculate mean power in band</span>
        <span class="n">band_powers</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">[</span><span class="n">idx_band</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">band_powers</span>

<span class="k">def</span><span class="w"> </span><span class="nf">extract_spike_features</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract features from spike train data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spike_times: Array of spike times in seconds</span>
<span class="sd">        duration: Total duration of recording in seconds</span>
<span class="sd">        bin_size: Bin size for rate calculation in seconds</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        features: Dictionary of spike train features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create binned spike counts</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span> <span class="o">/</span> <span class="n">bin_size</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">n_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">spike_counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
    
    <span class="c1"># Calculate features</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;firing_rate&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span><span class="p">,</span>  <span class="c1"># in Hz</span>
        <span class="s1">&#39;cv&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">spike_times</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">spike_times</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># Coefficient of variation</span>
        <span class="s1">&#39;burst_index&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spike_counts</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_bins</span><span class="p">,</span>  <span class="c1"># Fraction of bins with &gt;3 spikes</span>
        <span class="s1">&#39;fano_factor&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># Fano factor</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">features</span>
</pre></div>
</div>
</section>
<section id="normalization-approaches">
<h3>8.2.4 Normalization Approaches<a class="headerlink" href="#normalization-approaches" title="Link to this heading">#</a></h3>
<p>Proper normalization is essential for comparing across different recordings or subjects.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">normalize_neural_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;zscore&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize neural data using different approaches.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        data: Neural data array</span>
<span class="sd">        method: Normalization method (&#39;zscore&#39;, &#39;minmax&#39;, or &#39;robust&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        normalized_data: Normalized data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;zscore&#39;</span><span class="p">:</span>
        <span class="c1"># Z-score normalization (mean=0, std=1)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">normalized_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># Avoid division by zero</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="c1"># Min-max normalization (range [0, 1])</span>
        <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">normalized_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
        <span class="c1"># Robust scaling using median and IQR</span>
        <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">q75</span><span class="p">,</span> <span class="n">q25</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span> <span class="mi">25</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">iqr</span> <span class="o">=</span> <span class="n">q75</span> <span class="o">-</span> <span class="n">q25</span>
        <span class="n">normalized_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">median</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">iqr</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">normalized_data</span>
</pre></div>
</div>
</section>
</section>
<section id="exploratory-analysis">
<h2>8.3 Exploratory Analysis<a class="headerlink" href="#exploratory-analysis" title="Link to this heading">#</a></h2>
<p>Effective exploratory analysis reveals patterns and guides subsequent modeling.</p>
<section id="descriptive-statistics-for-neural-data">
<h3>8.3.1 Descriptive Statistics for Neural Data<a class="headerlink" href="#descriptive-statistics-for-neural-data" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_neural_statistics</span><span class="p">(</span><span class="n">spike_trains</span><span class="p">,</span> <span class="n">lfp_signals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute basic statistics for neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spike_trains: Dictionary of neuron_id -&gt; spike times</span>
<span class="sd">        lfp_signals: Dictionary of channel_id -&gt; LFP signal</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        stats: Dictionary of statistics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;spiking&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;lfp&#39;</span><span class="p">:</span> <span class="p">{}}</span>
    
    <span class="c1"># Spiking statistics</span>
    <span class="k">for</span> <span class="n">neuron_id</span><span class="p">,</span> <span class="n">spikes</span> <span class="ow">in</span> <span class="n">spike_trains</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">isi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span>  <span class="c1"># Inter-spike intervals</span>
            <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;spiking&#39;</span><span class="p">][</span><span class="n">neuron_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;firing_rate&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">spikes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">spikes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="s1">&#39;mean_isi&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">isi</span><span class="p">),</span>
                <span class="s1">&#39;cv_isi&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">isi</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">isi</span><span class="p">),</span>
                <span class="s1">&#39;burst_index&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">isi</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">isi</span><span class="p">)</span>  <span class="c1"># Fraction of ISIs &lt; 10 ms</span>
            <span class="p">}</span>
    
    <span class="c1"># LFP statistics</span>
    <span class="k">for</span> <span class="n">channel_id</span><span class="p">,</span> <span class="n">lfp</span> <span class="ow">in</span> <span class="n">lfp_signals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;lfp&#39;</span><span class="p">][</span><span class="n">channel_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lfp</span><span class="p">),</span>
            <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">lfp</span><span class="p">),</span>
            <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lfp</span><span class="p">),</span>
            <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lfp</span><span class="p">),</span>
            <span class="s1">&#39;power&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lfp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">stats</span>
</pre></div>
</div>
</section>
<section id="visualization-techniques">
<h3>8.3.2 Visualization Techniques<a class="headerlink" href="#visualization-techniques" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">visualize_neural_data</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create common visualizations for neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spike_times: List of spike times in seconds</span>
<span class="sd">        lfp_data: LFP signal array</span>
<span class="sd">        sampling_rate: Sampling rate in Hz</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span> <span class="k">as</span> <span class="n">sp_signal</span>
    
    <span class="c1"># Create figure with multiple plots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Time axis for LFP (assuming LFP starts at time 0)</span>
    <span class="n">t_lfp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">))</span> <span class="o">/</span> <span class="n">sampling_rate</span>
    
    <span class="c1"># Plot 1: Raw LFP trace</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_lfp</span><span class="p">,</span> <span class="n">lfp_data</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;LFP (μV)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Raw LFP Signal&#39;</span><span class="p">)</span>
    
    <span class="c1"># Plot 2: Spectrogram</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">lfp_data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span><span class="p">),</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;gouraud&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;LFP Spectrogram&#39;</span><span class="p">)</span>
    
    <span class="c1"># Plot 3: Spike raster</span>
    <span class="k">if</span> <span class="n">spike_times</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">eventplot</span><span class="p">([</span><span class="n">spike_times</span><span class="p">],</span> <span class="n">lineoffsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linelengths</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Spike Raster&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_firing_rate_heatmap</span><span class="p">(</span><span class="n">spike_times_dict</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a heatmap of firing rates over time.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spike_times_dict: Dictionary mapping neuron_id to spike times</span>
<span class="sd">        bin_size: Bin size for rate calculation in seconds</span>
<span class="sd">        duration: Total duration; if None, inferred from data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    
    <span class="c1"># Determine duration if not provided</span>
    <span class="k">if</span> <span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">spike_times_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_spikes</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_spikes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span>
    
    <span class="c1"># Create time bins</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span> <span class="o">+</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">)</span>
    <span class="n">neuron_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spike_times_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    
    <span class="c1"># Calculate binned spike counts</span>
    <span class="n">binned_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_ids</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neuron_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_ids</span><span class="p">):</span>
        <span class="n">counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">spike_times_dict</span><span class="p">[</span><span class="n">neuron_id</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">binned_rates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">bin_size</span>  <span class="c1"># Convert to Hz</span>
    
    <span class="c1"># Sort neurons by average firing rate</span>
    <span class="n">avg_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">binned_rates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">avg_rates</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Descending order</span>
    <span class="n">binned_rates</span> <span class="o">=</span> <span class="n">binned_rates</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">sorted_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_idx</span><span class="p">]</span>
    
    <span class="c1"># Plot heatmap</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">binned_rates</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span>
                  <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_ids</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron (sorted by firing rate)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Firing Rate Heatmap&#39;</span><span class="p">)</span>
    
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fig</span>
</pre></div>
</div>
</section>
<section id="dimensionality-reduction-and-visualization">
<h3>8.3.3 Dimensionality Reduction and Visualization<a class="headerlink" href="#dimensionality-reduction-and-visualization" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">visualize_neural_trajectories</span><span class="p">(</span><span class="n">neural_activity</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pca&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize neural trajectories using dimensionality reduction.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        neural_activity: Array of shape (n_neurons, n_timepoints)</span>
<span class="sd">        times: Time points corresponding to neural activity</span>
<span class="sd">        events: Optional dictionary of event_name -&gt; event_times</span>
<span class="sd">        method: Dimensionality reduction method (&#39;pca&#39; or &#39;tsne&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.mplot3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axes3D</span>
    
    <span class="c1"># Transpose to (n_timepoints, n_neurons) for sklearn</span>
    <span class="n">activity_T</span> <span class="o">=</span> <span class="n">neural_activity</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># Apply dimensionality reduction</span>
    <span class="n">reduced_data</span> <span class="o">=</span> <span class="n">apply_dimensionality_reduction</span><span class="p">(</span><span class="n">activity_T</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># Create 3D trajectory plot</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    
    <span class="c1"># Color dots based on time</span>
    <span class="n">scatter</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
    
    <span class="c1"># Plot trajectory line</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> 
           <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Mark events if provided</span>
    <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">tab10</span><span class="o">.</span><span class="n">colors</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">event_name</span><span class="p">,</span> <span class="n">event_times</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">event_time</span> <span class="ow">in</span> <span class="n">event_times</span><span class="p">:</span>
                <span class="c1"># Find closest timepoint</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">times</span> <span class="o">-</span> <span class="n">event_time</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                          <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)],</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">event_name</span> <span class="k">if</span> <span class="n">event_time</span> <span class="o">==</span> <span class="n">event_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1"> Component 1&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1"> Component 2&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1"> Component 3&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Neural Trajectories (</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fig</span>
</pre></div>
</div>
</section>
<section id="time-frequency-analysis">
<h3>8.3.4 Time-Frequency Analysis<a class="headerlink" href="#time-frequency-analysis" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_time_frequency</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;wavelet&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform time-frequency analysis on neural signals.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        signal: Time series data</span>
<span class="sd">        sampling_rate: Sampling rate in Hz</span>
<span class="sd">        method: Method to use (&#39;stft&#39;, &#39;wavelet&#39;, or &#39;multitaper&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        time: Time points</span>
<span class="sd">        frequencies: Frequency values</span>
<span class="sd">        power: Time-frequency power values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span> <span class="k">as</span> <span class="n">sp_signal</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;stft&#39;</span><span class="p">:</span>
        <span class="c1"># Short-time Fourier transform</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span>
            <span class="n">signal</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="n">sampling_rate</span><span class="o">//</span><span class="mi">10</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">sampling_rate</span><span class="o">//</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># Convert to dB</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">power</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;wavelet&#39;</span><span class="p">:</span>
        <span class="c1"># Continuous wavelet transform</span>
        <span class="c1"># Define frequencies of interest (1-100 Hz, logarithmically spaced)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">50</span><span class="p">)</span>
        
        <span class="c1"># Time vector</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span> <span class="o">/</span> <span class="n">sampling_rate</span>
        
        <span class="c1"># Compute wavelet transform (simplified example)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)))</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frequencies</span><span class="p">):</span>
            <span class="c1"># Calculate appropriate scales for Morlet wavelet</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
            <span class="n">wavelet</span> <span class="o">=</span> <span class="n">sp_signal</span><span class="o">.</span><span class="n">morlet2</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)),</span> <span class="n">scale</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            
            <span class="c1"># Convolve signal with wavelet</span>
            <span class="n">power</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sp_signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">wavelet</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="k">return</span> <span class="n">time</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">power</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;multitaper&#39;</span><span class="p">:</span>
        <span class="c1"># Multitaper method (using spectrum_fft function)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multitaper method requires specialized libraries like nitime or spectrum.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using spectrogram method instead.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">compute_time_frequency</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;stft&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="statistical-modeling">
<h2>8.4 Statistical Modeling<a class="headerlink" href="#statistical-modeling" title="Link to this heading">#</a></h2>
<section id="generalized-linear-models-for-neural-data">
<h3>8.4.1 Generalized Linear Models for Neural Data<a class="headerlink" href="#generalized-linear-models-for-neural-data" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_neural_glm</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">,</span> <span class="n">covariates</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;poisson&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a generalized linear model to neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spike_counts: Array of spike counts (n_trials, n_neurons)</span>
<span class="sd">        covariates: Array of predictor variables (n_trials, n_features)</span>
<span class="sd">        family: Distribution family (&#39;poisson&#39;, &#39;binomial&#39;, or &#39;gaussian&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        results: GLM results dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">statsmodels.api</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sm</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n_neurons</span> <span class="o">=</span> <span class="n">spike_counts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
        <span class="c1"># Create DataFrame for StatsModels</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">covariates</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;spike_count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spike_counts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># Define model formula</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;spike_count&#39;</span><span class="p">]</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;spike_count&#39;</span><span class="p">]))</span>
        
        <span class="c1"># Fit GLM with appropriate family</span>
        <span class="k">if</span> <span class="n">family</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Poisson</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">family</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Binomial</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># gaussian</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">GLM</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">families</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">())</span>
            
        <span class="n">model_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        
        <span class="c1"># Store results</span>
        <span class="n">results</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;neuron_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;coefficients&#39;</span><span class="p">:</span> <span class="n">model_results</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
            <span class="s1">&#39;pvalues&#39;</span><span class="p">:</span> <span class="n">model_results</span><span class="o">.</span><span class="n">pvalues</span><span class="p">,</span>
            <span class="s1">&#39;deviance&#39;</span><span class="p">:</span> <span class="n">model_results</span><span class="o">.</span><span class="n">deviance</span><span class="p">,</span>
            <span class="s1">&#39;aic&#39;</span><span class="p">:</span> <span class="n">model_results</span><span class="o">.</span><span class="n">aic</span><span class="p">,</span>
            <span class="s1">&#39;bic&#39;</span><span class="p">:</span> <span class="n">model_results</span><span class="o">.</span><span class="n">bic</span><span class="p">,</span>
            <span class="s1">&#39;summary&#39;</span><span class="p">:</span> <span class="n">model_results</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
        <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="point-process-models-for-spike-trains">
<h3>8.4.2 Point Process Models for Spike Trains<a class="headerlink" href="#point-process-models-for-spike-trains" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_point_process_model</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">covariates</span><span class="p">,</span> <span class="n">covariate_times</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a point process model to spike train data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        spike_times: Array of spike times in ms</span>
<span class="sd">        covariates: Dictionary of covariate_name -&gt; covariate_values</span>
<span class="sd">        covariate_times: Time points for covariates</span>
<span class="sd">        window_size: Window size in ms for history effects</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        model_results: Point process model results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is a simplified example of point process modeling</span>
    <span class="c1"># Real implementations would use specialized libraries</span>
    
    <span class="c1"># Bin spikes (1 ms bins)</span>
    <span class="n">max_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">spike_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">covariate_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">covariate_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">spike_counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">spike_times</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
    
    <span class="c1"># Interpolate covariates to match spike bins</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>
    
    <span class="n">interp_covariates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">covariates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">covariate_times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="n">interp_covariates</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Create design matrix with history terms</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">interp_covariates</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">covariates</span><span class="p">])</span>
    
    <span class="c1"># Add spike history terms</span>
    <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">spike_counts</span><span class="p">)</span>
        <span class="n">history</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span> <span class="o">=</span> <span class="n">spike_counts</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">history</span><span class="p">))</span>
    
    <span class="c1"># Fit GLM (Poisson regression)</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">PoissonRegressor</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="n">PoissonRegressor</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># L2 regularization</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">spike_counts</span><span class="p">)</span>
    
    <span class="c1"># Calculate model performance</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spike_counts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">predicted</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span> <span class="o">-</span> <span class="n">predicted</span><span class="p">)</span>
    
    <span class="n">feature_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">covariates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;history_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;coefficients&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">coef_</span><span class="p">)),</span>
        <span class="s1">&#39;log_likelihood&#39;</span><span class="p">:</span> <span class="n">ll</span><span class="p">,</span>
        <span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="n">model</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="bayesian-approaches">
<h3>8.4.3 Bayesian Approaches<a class="headerlink" href="#bayesian-approaches" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">fit_bayesian_neural_model</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">covariates</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a Bayesian model to neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        neural_data: Neural activity data (n_samples, n_neurons)</span>
<span class="sd">        covariates: Predictor variables (n_samples, n_features)</span>
<span class="sd">        model_type: Type of model (&#39;linear&#39;, &#39;hierarchical&#39;, or &#39;mixture&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        model_results: Dictionary of model results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: This is a placeholder for Bayesian modeling</span>
    <span class="c1"># In practice, you would use PyMC3, Stan, or other Bayesian libraries</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bayesian modeling in neuroscience typically uses:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. PyMC3 or PyMC for Python-based probabilistic programming&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2. Stan for high-performance Bayesian inference&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3. BayesOpt for Bayesian optimization of models&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Linear Bayesian model: y ~ Normal(X*β, σ)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with priors: β ~ Normal(0, τ), σ ~ HalfCauchy(5)&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hierarchical Bayesian model for neurons with shared parameters&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Individual neuron parameters drawn from population distribution&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;mixture&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mixture model for detecting different neural states or clusters&quot;</span><span class="p">)</span>
    
    <span class="c1"># Return placeholder results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;model_type&#39;</span><span class="p">:</span> <span class="n">model_type</span><span class="p">,</span>
        <span class="s1">&#39;n_neurons&#39;</span><span class="p">:</span> <span class="n">neural_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s1">&#39;n_covariates&#39;</span><span class="p">:</span> <span class="n">covariates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="s2">&quot;This is a placeholder for actual Bayesian modeling with PyMC or Stan.&quot;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="model-validation-techniques">
<h3>8.4.4 Model Validation Techniques<a class="headerlink" href="#model-validation-techniques" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_neural_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cross_validation&#39;</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate a neural data model using various techniques.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        model: Fitted model object with predict method</span>
<span class="sd">        X: Features/covariates</span>
<span class="sd">        y: Target variable (neural activity)</span>
<span class="sd">        method: Validation method (&#39;cross_validation&#39;, &#39;bootstrap&#39;, or &#39;timeseries_split&#39;)</span>
<span class="sd">        n_splits: Number of splits for cross-validation</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        metrics: Dictionary of validation metrics</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">KFold</span><span class="p">,</span> <span class="n">TimeSeriesSplit</span><span class="p">,</span> <span class="n">cross_val_score</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">mean_squared_error</span><span class="p">,</span> <span class="n">r2_score</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    
    <span class="n">metrics</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cross_validation&#39;</span><span class="p">:</span>
        <span class="c1"># K-fold cross-validation</span>
        <span class="n">kf</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">n_splits</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        
        <span class="n">mse_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_squared_error&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">kf</span><span class="p">)</span>
        <span class="n">r2_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;r2&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">kf</span><span class="p">)</span>
        
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mse_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mse_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mse_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;r2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r2_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;r2_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">r2_scores</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">:</span>
        <span class="c1"># Bootstrap validation</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">resample</span>
        
        <span class="n">mse_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">r2_scores</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_splits</span><span class="p">):</span>
            <span class="c1"># Create bootstrap sample</span>
            <span class="n">X_boot</span><span class="p">,</span> <span class="n">y_boot</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            
            <span class="c1"># Fit model on bootstrap sample</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_boot</span><span class="p">,</span> <span class="n">y_boot</span><span class="p">)</span>
            
            <span class="c1"># Predict on original data</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            
            <span class="c1"># Compute metrics</span>
            <span class="n">mse_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
            <span class="n">r2_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r2_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
        
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mse_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mse_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mse_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;r2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r2_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;r2_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">r2_scores</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;timeseries_split&#39;</span><span class="p">:</span>
        <span class="c1"># Time series cross-validation</span>
        <span class="n">tscv</span> <span class="o">=</span> <span class="n">TimeSeriesSplit</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">n_splits</span><span class="p">)</span>
        
        <span class="n">mse_scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">r2_scores</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="ow">in</span> <span class="n">tscv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
            <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
            <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
            
            <span class="c1"># Fit and predict</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            
            <span class="c1"># Compute metrics</span>
            <span class="n">mse_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
            <span class="n">r2_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
        
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mse_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;mse_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mse_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;r2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r2_scores</span><span class="p">)</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s1">&#39;r2_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">r2_scores</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">metrics</span>
</pre></div>
</div>
</section>
</section>
<section id="machine-learning-applications">
<h2>8.5 Machine Learning Applications<a class="headerlink" href="#machine-learning-applications" title="Link to this heading">#</a></h2>
<section id="supervised-learning-for-neural-decoding">
<h3>8.5.1 Supervised Learning for Neural Decoding<a class="headerlink" href="#supervised-learning-for-neural-decoding" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">neural_decoding</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">stimulus</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;svm&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode stimuli or behavior from neural activity.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        neural_data: Neural features (n_samples, n_features)</span>
<span class="sd">        stimulus: Target variable to decode (n_samples,)</span>
<span class="sd">        test_size: Proportion of data to use for testing</span>
<span class="sd">        classifier_type: Type of classifier (&#39;svm&#39;, &#39;rf&#39;, or &#39;lda&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        results: Dictionary of decoding results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.svm</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVC</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.ensemble</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomForestClassifier</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.discriminant_analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearDiscriminantAnalysis</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">classification_report</span>
    
    <span class="c1"># Split data</span>
    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">neural_data</span><span class="p">,</span> <span class="n">stimulus</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    
    <span class="c1"># Standardize features</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">X_train_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
    <span class="n">X_test_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
    
    <span class="c1"># Select and train classifier</span>
    <span class="k">if</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;svm&#39;</span><span class="p">:</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;rf&#39;</span><span class="p">:</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;lda&#39;</span><span class="p">:</span>
        <span class="n">classifier</span> <span class="o">=</span> <span class="n">LinearDiscriminantAnalysis</span><span class="p">()</span>
    
    <span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    
    <span class="c1"># Make predictions</span>
    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="p">)</span>
    <span class="n">y_prob</span> <span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">classifier</span><span class="p">,</span> <span class="s1">&#39;predict_proba&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
    
    <span class="c1"># Evaluate performance</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
    <span class="n">conf_matrix</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
    <span class="n">class_report</span> <span class="o">=</span> <span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">output_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Compile results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;classifier_type&#39;</span><span class="p">:</span> <span class="n">classifier_type</span><span class="p">,</span>
        <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">accuracy</span><span class="p">,</span>
        <span class="s1">&#39;confusion_matrix&#39;</span><span class="p">:</span> <span class="n">conf_matrix</span><span class="p">,</span>
        <span class="s1">&#39;classification_report&#39;</span><span class="p">:</span> <span class="n">class_report</span><span class="p">,</span>
        <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="n">classifier</span><span class="p">,</span>
        <span class="s1">&#39;scaler&#39;</span><span class="p">:</span> <span class="n">scaler</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="n">y_prob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;prediction_probabilities&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_prob</span>
    
    <span class="k">return</span> <span class="n">results</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_decoding_results</span><span class="p">(</span><span class="n">decoding_results</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize neural decoding results.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        decoding_results: Results from neural_decoding function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
    
    <span class="c1"># Create figure with subplots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    
    <span class="c1"># Plot confusion matrix</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;confusion_matrix&#39;</span><span class="p">],</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">,</span>
                <span class="n">xticklabels</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;classification_report&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">yticklabels</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;classification_report&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Confusion Matrix</span><span class="se">\n</span><span class="s2">Accuracy: </span><span class="si">{</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Predicted&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">)</span>
    
    <span class="c1"># Plot class performance</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;classification_report&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">f1_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;classification_report&#39;</span><span class="p">][</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;f1-score&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">]</span>
    
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">f1_scores</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;F1 Score by Class&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;F1 Score&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Class&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span>
</pre></div>
</div>
</section>
<section id="unsupervised-learning-for-pattern-discovery">
<h3>8.5.2 Unsupervised Learning for Pattern Discovery<a class="headerlink" href="#unsupervised-learning-for-pattern-discovery" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">discover_neural_patterns</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;clustering&#39;</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Discover patterns in neural data using unsupervised learning.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        neural_data: Neural activity data (n_samples, n_features)</span>
<span class="sd">        method: Method to use (&#39;clustering&#39;, &#39;hmm&#39;, or &#39;nmf&#39;)</span>
<span class="sd">        n_clusters: Number of clusters/components to find</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        results: Dictionary with pattern discovery results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">DBSCAN</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">NMF</span><span class="p">,</span> <span class="n">PCA</span>
    
    <span class="c1"># Standardize data</span>
    <span class="n">scaled_data</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">neural_data</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;clustering&#39;</span><span class="p">:</span>
        <span class="c1"># K-means clustering</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>
        
        <span class="c1"># Compute cluster statistics</span>
        <span class="n">cluster_stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">neural_data</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">cluster_stats</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;cluster_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;percentage&#39;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">neural_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
        
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;k-means&#39;</span><span class="p">,</span>
            <span class="s1">&#39;clusters&#39;</span><span class="p">:</span> <span class="n">clusters</span><span class="p">,</span>
            <span class="s1">&#39;cluster_centers&#39;</span><span class="p">:</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span>
            <span class="s1">&#39;cluster_stats&#39;</span><span class="p">:</span> <span class="n">cluster_stats</span><span class="p">,</span>
            <span class="s1">&#39;inertia&#39;</span><span class="p">:</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">inertia_</span><span class="p">,</span>
            <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="n">n_clusters</span>
        <span class="p">}</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hmm&#39;</span><span class="p">:</span>
        <span class="c1"># Hidden Markov Model</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">hmmlearn</span><span class="w"> </span><span class="kn">import</span> <span class="n">hmm</span>
            
            <span class="c1"># Fit HMM</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">GaussianHMM</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">covariance_type</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>
            
            <span class="c1"># Decode states</span>
            <span class="n">states</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">scaled_data</span><span class="p">)</span>
            
            <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;hmm&#39;</span><span class="p">,</span>
                <span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="n">states</span><span class="p">,</span>
                <span class="s1">&#39;state_means&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">means_</span><span class="p">,</span>
                <span class="s1">&#39;state_covars&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">covars_</span><span class="p">,</span>
                <span class="s1">&#39;transition_matrix&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">transmat_</span><span class="p">,</span>
                <span class="s1">&#39;n_states&#39;</span><span class="p">:</span> <span class="n">n_clusters</span>
            <span class="p">}</span>
            
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hmmlearn not installed. Install with: pip install hmmlearn&quot;</span><span class="p">)</span>
            <span class="c1"># Fallback to k-means</span>
            <span class="k">return</span> <span class="n">discover_neural_patterns</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;clustering&#39;</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nmf&#39;</span><span class="p">:</span>
        <span class="c1"># Non-negative Matrix Factorization</span>
        <span class="c1"># Ensure data is non-negative</span>
        <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">neural_data</span><span class="p">)</span>
        <span class="n">shifted_data</span> <span class="o">=</span> <span class="n">neural_data</span> <span class="o">-</span> <span class="n">min_val</span> <span class="k">if</span> <span class="n">min_val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">neural_data</span>
        
        <span class="c1"># Fit NMF</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">shifted_data</span><span class="p">)</span>  <span class="c1"># Weights</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">components_</span>  <span class="c1"># Components</span>
        
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;nmf&#39;</span><span class="p">,</span>
            <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">,</span>
            <span class="s1">&#39;components&#39;</span><span class="p">:</span> <span class="n">H</span><span class="p">,</span>
            <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="n">n_clusters</span><span class="p">,</span>
            <span class="s1">&#39;reconstruction_error&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">reconstruction_err_</span>
        <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">results</span>

<span class="k">def</span><span class="w"> </span><span class="nf">visualize_neural_patterns</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">,</span> <span class="n">neural_data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize patterns discovered in neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        pattern_results: Results from discover_neural_patterns function</span>
<span class="sd">        neural_data: Original neural data</span>
<span class="sd">        times: Time points corresponding to neural data (optional)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
    
    <span class="c1"># Create figure with subplots</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    
    <span class="c1"># Reduce dimensionality for visualization</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">reduced_data</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">neural_data</span><span class="p">)</span>
    
    <span class="c1"># Plot 1: PCA with clusters or states</span>
    <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;k-means&#39;</span><span class="p">,</span> <span class="s1">&#39;hmm&#39;</span><span class="p">]:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k-means&#39;</span> <span class="k">else</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span>
        
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> 
                               <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k-means&#39;</span><span class="p">:</span>
            <span class="c1"># Transform cluster centers to PCA space</span>
            <span class="n">centers</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;cluster_centers&#39;</span><span class="p">])</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cluster/State&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PCA Projection with </span><span class="si">{</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2"> Labels&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># NMF</span>
        <span class="c1"># For NMF, color by the dominant component</span>
        <span class="n">dominant_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">dominant_comp</span><span class="p">,</span> 
                               <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Dominant Component&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;PCA Projection with Dominant NMF Component&quot;</span><span class="p">)</span>
    
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;PC1&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PC2&#39;</span><span class="p">)</span>
    
    <span class="c1"># Plot 2: Pattern profiles</span>
    <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k-means&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">center</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;cluster_centers&#39;</span><span class="p">]):</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Cluster Centers&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Feature&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        
    <span class="k">elif</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;hmm&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mean</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;state_means&#39;</span><span class="p">]):</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;State </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;State Means&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Feature&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># NMF</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;components&#39;</span><span class="p">]):</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;NMF Components&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Feature&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Weight&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 3: Time series (if time information provided)</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;k-means&#39;</span><span class="p">,</span> <span class="s1">&#39;hmm&#39;</span><span class="p">]:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k-means&#39;</span> <span class="k">else</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span>
            
            <span class="c1"># Plot the first 3 neurons with cluster/state coloring</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">neural_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">neural_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                
            <span class="c1"># Color the background by state/cluster</span>
            <span class="n">n_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">n_labels</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">label</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                    <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="kc">False</span><span class="p">],</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]))))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">segments</span> <span class="o">=</span> <span class="n">segments</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
                        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Neural Activity with Clusters/States&quot;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Activity&quot;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># NMF</span>
            <span class="c1"># Plot component activations over time</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;n_components&#39;</span><span class="p">],</span> <span class="mi">5</span><span class="p">)):</span>
                <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Comp </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Component Activations Over Time&quot;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Activation&quot;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 4: Additional analysis</span>
    <span class="k">if</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k-means&#39;</span><span class="p">:</span>
        <span class="c1"># Silhouette score plot or cluster distribution</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stats</span> <span class="ow">in</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;cluster_stats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Cluster </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">))]</span>
        
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">autopct</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.1f%%</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">startangle</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Cluster Distribution&quot;</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;hmm&#39;</span><span class="p">:</span>
        <span class="c1"># Transition matrix as heatmap</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
        <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;transition_matrix&#39;</span><span class="p">],</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;HMM Transition Matrix&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;To State&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;From State&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># NMF</span>
        <span class="c1"># Component importance or reconstruction error</span>
        <span class="n">explained_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">explained_var_ratio</span> <span class="o">=</span> <span class="n">explained_var</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">explained_var</span><span class="p">)</span>
        
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">explained_var_ratio</span><span class="p">)),</span> <span class="n">explained_var_ratio</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Component Variance Contribution&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Component&quot;</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Variance Ratio&quot;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span>
</pre></div>
</div>
</section>
<section id="deep-learning-approaches-for-neural-data">
<h3>8.5.3 Deep Learning Approaches for Neural Data<a class="headerlink" href="#deep-learning-approaches-for-neural-data" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">create_neural_network_model</span><span class="p">(</span><span class="n">input_shape</span><span class="p">,</span> <span class="n">output_size</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;cnn&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create deep learning models for neural data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input_shape: Shape of input data (e.g., (time_steps, features))</span>
<span class="sd">        output_size: Number of output classes or continuous outputs</span>
<span class="sd">        model_type: Type of model (&#39;cnn&#39;, &#39;rnn&#39;, or &#39;transformer&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        model: Compiled neural network model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is a placeholder for deep learning models</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building deep neural networks for neural data typically requires:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1. TensorFlow or PyTorch for implementing the models&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2. Careful consideration of input data shape and temporal dynamics&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3. Appropriate regularization to prevent overfitting with limited data&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;cnn&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CNNs are useful for spatial patterns in neural data, e.g., EEG topographies&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Typical architecture: Conv1D layers for temporal data or Conv2D for images&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;rnn&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RNNs/LSTMs are ideal for temporal sequences in neural data&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Typical architecture: LSTM or GRU layers followed by dense layers&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;transformer&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transformers with attention can model long-range dependencies in neural data&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Typical architecture: Self-attention layers with position encoding&quot;</span><span class="p">)</span>
    
    <span class="c1"># Return placeholder results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;model_type&#39;</span><span class="p">:</span> <span class="n">model_type</span><span class="p">,</span>
        <span class="s1">&#39;input_shape&#39;</span><span class="p">:</span> <span class="n">input_shape</span><span class="p">,</span>
        <span class="s1">&#39;output_size&#39;</span><span class="p">:</span> <span class="n">output_size</span><span class="p">,</span>
        <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="s2">&quot;This is a placeholder for actual deep learning model implementation&quot;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="transfer-learning-and-domain-adaptation">
<h3>8.5.4 Transfer Learning and Domain Adaptation<a class="headerlink" href="#transfer-learning-and-domain-adaptation" title="Link to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">transfer_learning_neural_model</span><span class="p">(</span><span class="n">source_data</span><span class="p">,</span> <span class="n">source_labels</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply transfer learning for neural data analysis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        source_data: Data from source domain</span>
<span class="sd">        source_labels: Labels from source domain</span>
<span class="sd">        target_data: Data from target domain</span>
<span class="sd">        target_labels: Labels from target domain (can be limited)</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        results: Transfer learning results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.ensemble</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomForestClassifier</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">accuracy_score</span>
    
    <span class="c1"># This is a simplified example of transfer learning</span>
    <span class="c1"># In practice, you would use neural networks and proper domain adaptation</span>
    
    <span class="c1"># Split target data into train/test</span>
    <span class="n">X_target_train</span><span class="p">,</span> <span class="n">X_target_test</span><span class="p">,</span> <span class="n">y_target_train</span><span class="p">,</span> <span class="n">y_target_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">target_data</span><span class="p">,</span> <span class="n">target_labels</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    
    <span class="c1"># Baseline model: train on target data only</span>
    <span class="n">baseline_model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">baseline_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_target_train</span><span class="p">,</span> <span class="n">y_target_train</span><span class="p">)</span>
    <span class="n">baseline_pred</span> <span class="o">=</span> <span class="n">baseline_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_target_test</span><span class="p">)</span>
    <span class="n">baseline_acc</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_target_test</span><span class="p">,</span> <span class="n">baseline_pred</span><span class="p">)</span>
    
    <span class="c1"># Transfer learning approach: train on source + target data</span>
    <span class="n">combined_X_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">source_data</span><span class="p">,</span> <span class="n">X_target_train</span><span class="p">])</span>
    <span class="n">combined_y_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">source_labels</span><span class="p">,</span> <span class="n">y_target_train</span><span class="p">])</span>
    
    <span class="n">transfer_model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">transfer_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">combined_X_train</span><span class="p">,</span> <span class="n">combined_y_train</span><span class="p">)</span>
    <span class="n">transfer_pred</span> <span class="o">=</span> <span class="n">transfer_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_target_test</span><span class="p">)</span>
    <span class="n">transfer_acc</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_target_test</span><span class="p">,</span> <span class="n">transfer_pred</span><span class="p">)</span>
    
    <span class="c1"># Feature-based transfer (simple approach)</span>
    <span class="c1"># Train on source data, use predicted probabilities as features for target model</span>
    <span class="n">source_model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">source_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">source_data</span><span class="p">,</span> <span class="n">source_labels</span><span class="p">)</span>
    
    <span class="c1"># Get predicted probabilities as features</span>
    <span class="n">source_features_train</span> <span class="o">=</span> <span class="n">source_model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_target_train</span><span class="p">)</span>
    <span class="n">source_features_test</span> <span class="o">=</span> <span class="n">source_model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_target_test</span><span class="p">)</span>
    
    <span class="c1"># Train target model with these features</span>
    <span class="n">feature_transfer_model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">feature_transfer_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">source_features_train</span><span class="p">,</span> <span class="n">y_target_train</span><span class="p">)</span>
    <span class="n">feature_transfer_pred</span> <span class="o">=</span> <span class="n">feature_transfer_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">source_features_test</span><span class="p">)</span>
    <span class="n">feature_transfer_acc</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_target_test</span><span class="p">,</span> <span class="n">feature_transfer_pred</span><span class="p">)</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;baseline_accuracy&#39;</span><span class="p">:</span> <span class="n">baseline_acc</span><span class="p">,</span>
        <span class="s1">&#39;combined_transfer_accuracy&#39;</span><span class="p">:</span> <span class="n">transfer_acc</span><span class="p">,</span>
        <span class="s1">&#39;feature_transfer_accuracy&#39;</span><span class="p">:</span> <span class="n">feature_transfer_acc</span><span class="p">,</span>
        <span class="s1">&#39;baseline_model&#39;</span><span class="p">:</span> <span class="n">baseline_model</span><span class="p">,</span>
        <span class="s1">&#39;transfer_model&#39;</span><span class="p">:</span> <span class="n">transfer_model</span><span class="p">,</span>
        <span class="s1">&#39;feature_transfer_model&#39;</span><span class="p">:</span> <span class="n">feature_transfer_model</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
</section>
<section id="code-lab-building-an-end-to-end-pipeline">
<h2>8.6 Code Lab: Building an End-to-End Pipeline<a class="headerlink" href="#code-lab-building-an-end-to-end-pipeline" title="Link to this heading">#</a></h2>
<p>Let’s implement a complete neural data pipeline from preprocessing to analysis and visualization.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">neural_data_pipeline</span><span class="p">(</span><span class="n">raw_data_file</span><span class="p">,</span> <span class="n">metadata_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    End-to-end pipeline for neural data analysis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        raw_data_file: Path to raw neural data file</span>
<span class="sd">        metadata_file: Path to experiment metadata</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        results: Dictionary of analysis results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.ensemble</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomForestClassifier</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">classification_report</span>
    
    <span class="c1"># Step 1: Load and preprocess data</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 1: Loading and preprocessing data...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Simulated data loading (replace with actual loading code)</span>
    <span class="c1"># For demonstration, we&#39;ll generate synthetic data</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    
    <span class="c1"># Simulate multi-channel neural recordings (20 channels, 100000 samples)</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="mi">100000</span>
    <span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># Hz</span>
    
    <span class="c1"># Generate random neural data with some oscillatory components</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    
    <span class="c1"># Add alpha oscillations (8-12 Hz) to some channels</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling_rate</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">raw_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="mi">2</span>
    
    <span class="c1"># Add beta oscillations (15-30 Hz) to other channels</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">raw_data</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">beta</span> <span class="o">*</span> <span class="mf">1.5</span>
    
    <span class="c1"># Add gamma oscillations (30-80 Hz) to other channels</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">raw_data</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="mf">1.0</span>
    
    <span class="c1"># Simulate artifacts</span>
    <span class="n">artifact_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">artifact_indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n_samples</span> <span class="o">-</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">raw_data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">100</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span>
    
    <span class="c1"># Simulate experimental conditions/events</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rest&#39;</span><span class="p">,</span> <span class="s1">&#39;task_A&#39;</span><span class="p">,</span> <span class="s1">&#39;task_B&#39;</span><span class="p">]</span>
    <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="mi">10000</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">5000</span> <span class="o">&lt;</span> <span class="n">n_samples</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
            <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;start_time&#39;</span><span class="p">:</span> <span class="n">i</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="s1">&#39;end_time&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="n">cond</span>
            <span class="p">})</span>
    
    <span class="n">events_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    
    <span class="c1"># Step 2: Preprocessing</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 2: Applying filters and artifact removal...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Filter data</span>
    <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
        <span class="n">filtered_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">preprocess_neural_signal</span><span class="p">(</span>
            <span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">notch_freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">bandpass</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
    
    <span class="c1"># Detect and interpolate artifacts</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
        <span class="n">artifacts</span> <span class="o">=</span> <span class="n">detect_artifacts</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">artifacts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Simple interpolation for artifacts</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">artifacts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_samples</span> <span class="o">-</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="c1"># Linear interpolation</span>
                    <span class="n">filtered_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">filtered_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> 
                         <span class="n">filtered_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">11</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()])</span>
    
    <span class="c1"># Step 3: Feature extraction</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 3: Extracting features...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Calculate power in different frequency bands for each channel</span>
    <span class="n">freq_bands</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;delta&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
        <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1"># Extract features in windows</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># 1 second</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="mi">500</span>  <span class="c1"># 0.5 second overlap</span>
    
    <span class="n">n_windows</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">//</span> <span class="n">step_size</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_windows</span><span class="p">,</span> <span class="n">n_channels</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_bands</span><span class="p">)))</span>
    
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_windows</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">step_size</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">window_size</span>
        
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
            <span class="n">window_data</span> <span class="o">=</span> <span class="n">filtered_data</span><span class="p">[</span><span class="n">ch</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            
            <span class="c1"># Extract frequency features</span>
            <span class="n">freq_features</span> <span class="o">=</span> <span class="n">extract_frequency_features</span><span class="p">(</span>
                <span class="n">window_data</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">freq_bands</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">freq_bands</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            
            <span class="c1"># Store features</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">band</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freq_bands</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">features</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="n">ch</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_bands</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_features</span><span class="p">[</span><span class="n">band_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
    <span class="c1"># Create labels based on experimental conditions</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_windows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_windows</span><span class="p">):</span>
        <span class="n">window_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">step_size</span> <span class="o">+</span> <span class="n">window_size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling_rate</span>
        
        <span class="c1"># Find corresponding event</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">window_time</span> <span class="o">&lt;</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span>
                <span class="k">break</span>
        
        <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># No matching event</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
    
    <span class="c1"># Step 4: Dimensionality reduction</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 4: Applying dimensionality reduction...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Apply PCA to features</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">features_reduced</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Explained variance by PCA: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Step 5: Pattern discovery</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 5: Discovering patterns in data...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Apply clustering to find neural states</span>
    <span class="n">pattern_results</span> <span class="o">=</span> <span class="n">discover_neural_patterns</span><span class="p">(</span>
        <span class="n">features_reduced</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;clustering&#39;</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    
    <span class="c1"># Calculate state distributions across conditions</span>
    <span class="n">state_by_condition</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">cond</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">state_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">][</span><span class="n">mask</span><span class="p">],</span> 
                <span class="n">minlength</span><span class="o">=</span><span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;n_clusters&#39;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">state_by_condition</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_counts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">state_counts</span><span class="p">)</span>
    
    <span class="c1"># Step 6: Classification/decoding</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 6: Decoding neural states...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Only use windows with a condition label</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">features_reduced</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    
    <span class="c1"># Neural decoding</span>
    <span class="n">decoding_results</span> <span class="o">=</span> <span class="n">neural_decoding</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;rf&#39;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decoding accuracy: </span><span class="si">{</span><span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Step 7: Visualization</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 7: Generating visualizations...&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create plots</span>
    <span class="n">fig1</span> <span class="o">=</span> <span class="n">visualize_neural_patterns</span><span class="p">(</span>
        <span class="n">pattern_results</span><span class="p">,</span> <span class="n">features_reduced</span><span class="p">,</span> 
        <span class="n">times</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_windows</span><span class="p">)</span> <span class="o">*</span> <span class="n">step_size</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>
    
    <span class="n">fig2</span> <span class="o">=</span> <span class="n">plot_decoding_results</span><span class="p">(</span><span class="n">decoding_results</span><span class="p">)</span>
    
    <span class="c1"># Time-frequency plot for a sample channel</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># First channel</span>
    
    <span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">compute_time_frequency</span><span class="p">(</span>
        <span class="n">filtered_data</span><span class="p">[</span><span class="n">ch</span><span class="p">,</span> <span class="p">:</span><span class="mi">10000</span><span class="p">],</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;stft&#39;</span><span class="p">)</span>
    
    <span class="n">fig3</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span><span class="p">),</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;gouraud&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Time-Frequency Analysis - Channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Power (dB)&#39;</span><span class="p">)</span>
    
    <span class="c1"># Step 8: Compile results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;raw_data_shape&#39;</span><span class="p">:</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="s1">&#39;filtered_data_shape&#39;</span><span class="p">:</span> <span class="n">filtered_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="s1">&#39;features_shape&#39;</span><span class="p">:</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="s1">&#39;features_reduced_shape&#39;</span><span class="p">:</span> <span class="n">features_reduced</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="s1">&#39;n_events&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">),</span>
        <span class="s1">&#39;unique_conditions&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="s1">&#39;pca_explained_variance&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">),</span>
        <span class="s1">&#39;pattern_results&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;n_clusters&#39;</span><span class="p">],</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">pattern_results</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">],</span>
            <span class="s1">&#39;state_distribution&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state_by_condition</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="p">},</span>
        <span class="s1">&#39;decoding_results&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">],</span>
            <span class="s1">&#39;classifier_type&#39;</span><span class="p">:</span> <span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;classifier_type&#39;</span><span class="p">],</span>
            <span class="s1">&#39;class_performance&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;f1-score&#39;</span><span class="p">]</span> 
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">decoding_results</span><span class="p">[</span><span class="s1">&#39;classification_report&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="s1">&#39;macro avg&#39;</span><span class="p">,</span> <span class="s1">&#39;weighted avg&#39;</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="s1">&#39;figures&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;patterns&#39;</span><span class="p">:</span> <span class="n">fig1</span><span class="p">,</span>
            <span class="s1">&#39;decoding&#39;</span><span class="p">:</span> <span class="n">fig2</span><span class="p">,</span>
            <span class="s1">&#39;time_frequency&#39;</span><span class="p">:</span> <span class="n">fig3</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Neural data pipeline completed successfully!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="the-art-of-programming-for-neuroscience-data">
<h2>8.7 The Art of Programming for Neuroscience Data<a class="headerlink" href="#the-art-of-programming-for-neuroscience-data" title="Link to this heading">#</a></h2>
<section id="why-python-for-neural-data-analysis">
<h3>8.7.1 Why Python for Neural Data Analysis<a class="headerlink" href="#why-python-for-neural-data-analysis" title="Link to this heading">#</a></h3>
<p><img alt="Python Ecosystem for Neuroscience" src="../_images/python_neuro_ecosystem.svg" />
<em>Figure 8.3: The Python ecosystem for neuroscience, showing the relationships between core libraries, data processing tools, visualization packages, machine learning frameworks, and specialized neuroscience libraries.</em></p>
<p>Python has become the dominant programming language in neuroscience and data science for several compelling reasons:</p>
<ol class="arabic simple">
<li><p><strong>Ecosystem Maturity</strong>: Libraries like NumPy, SciPy, pandas, and matplotlib provide robust foundations for scientific computing.</p></li>
<li><p><strong>Domain-Specific Tools</strong>: Specialized packages like MNE-Python (for EEG/MEG), Neo (for electrophysiology), and CaImAn (for calcium imaging) make complex analyses accessible.</p></li>
<li><p><strong>Integration Capabilities</strong>: Python easily interfaces with other languages (C/C++, R) and platforms (MATLAB) commonly used in neuroscience.</p></li>
<li><p><strong>Balance of Readability and Power</strong>: Python’s clean syntax makes code readable while maintaining computational efficiency through vectorized operations and compiled extensions.</p></li>
<li><p><strong>Community Support</strong>: Active communities in both neuroscience and data science continuously contribute to tools and documentation.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example illustrating Python&#39;s readability and power for neural analysis</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="c1"># Define preprocessing function with clear, readable code</span>
<span class="k">def</span><span class="w"> </span><span class="nf">preprocess_neural_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Preprocess neural time series data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        raw_data: Raw neural signal (channels x time)</span>
<span class="sd">        sampling_rate: Recording sampling rate in Hz</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Preprocessed data and frequency analysis results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Apply bandpass filter (1-100 Hz)</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sampling_rate</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">nyq</span><span class="p">,</span> <span class="mi">100</span><span class="o">/</span><span class="n">nyq</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># 2. Remove line noise with notch filter</span>
    <span class="n">notch_b</span><span class="p">,</span> <span class="n">notch_a</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">iirnotch</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">notched</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">notch_b</span><span class="p">,</span> <span class="n">notch_a</span><span class="p">,</span> <span class="n">filtered</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># 3. Compute power spectrum</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">welch</span><span class="p">(</span><span class="n">notched</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># 4. Create results dataframe</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s1">&#39;theta_power&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">[:,</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="s1">&#39;alpha_power&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">[:,</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="s1">&#39;beta_power&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psd</span><span class="p">[:,</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">})</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;preprocessed_data&#39;</span><span class="p">:</span> <span class="n">notched</span><span class="p">,</span>
        <span class="s1">&#39;frequencies&#39;</span><span class="p">:</span> <span class="n">freqs</span><span class="p">,</span>
        <span class="s1">&#39;power_spectrum&#39;</span><span class="p">:</span> <span class="n">psd</span><span class="p">,</span>
        <span class="s1">&#39;band_powers&#39;</span><span class="p">:</span> <span class="n">results</span>
    <span class="p">}</span>

<span class="c1"># Clear, concise visualization of results</span>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_power_spectrum</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot power spectrum of neural data.&quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;frequencies&#39;</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;power_spectrum&#39;</span><span class="p">][</span><span class="n">channel</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density (μV²/Hz)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Neural Power Spectrum - Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="c1"># Add shaded areas for frequency bands</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Delta&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s1">&#39;Theta&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="s1">&#39;Alpha&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
        <span class="s1">&#39;Beta&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
        <span class="s1">&#39;Gamma&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;#E6F5FF&#39;</span><span class="p">,</span> <span class="s1">&#39;#CCEBFF&#39;</span><span class="p">,</span> <span class="s1">&#39;#99D6FF&#39;</span><span class="p">,</span> <span class="s1">&#39;#66C0FF&#39;</span><span class="p">,</span> <span class="s1">&#39;#33AAFF&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">band</span><span class="p">,</span> <span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)),</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bands</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">colors</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="from-code-to-concept-programming-as-scientific-thinking">
<h3>8.7.2 From Code to Concept: Programming as Scientific Thinking<a class="headerlink" href="#from-code-to-concept-programming-as-scientific-thinking" title="Link to this heading">#</a></h3>
<p>Effective data science in neuroscience is less about writing perfect code and more about translating scientific questions into computational approaches:</p>
<ol class="arabic simple">
<li><p><strong>Hypothesis-Driven Programming</strong>: Start with the scientific question, then determine the appropriate analysis approach.</p></li>
<li><p><strong>Iterative Development</strong>: Begin with a minimal viable analysis that addresses the core question, then refine.</p></li>
<li><p><strong>Visual Debugging</strong>: Continuously visualize intermediate results to catch errors and build intuition.</p></li>
<li><p><strong>Pipeline Thinking</strong>: Structure code as transformative steps in a data pipeline rather than monolithic scripts.</p></li>
<li><p><strong>Documenting Reasoning</strong>: Comment not just what code does, but why certain parameters or approaches were chosen.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example of hypothesis-driven programming for neural decoding</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_neural_decoding_hypothesis</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">stimulus_conditions</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test specific hypothesis about neural coding using appropriate analysis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        neural_data: Matrix of neural activity (neurons x time)</span>
<span class="sd">        stimulus_conditions: Experimental conditions at each timepoint</span>
<span class="sd">        hypothesis: Dict with hypothesis parameters</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary of results relevant to the hypothesis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract hypothesis parameters</span>
    <span class="n">feature_type</span> <span class="o">=</span> <span class="n">hypothesis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;feature_type&#39;</span><span class="p">,</span> <span class="s1">&#39;rate&#39;</span><span class="p">)</span>
    <span class="n">decoding_window</span> <span class="o">=</span> <span class="n">hypothesis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;decoding_window&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>
    <span class="n">model_type</span> <span class="o">=</span> <span class="n">hypothesis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;model_type&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    
    <span class="c1"># Convert hypothesis parameters to analysis approach</span>
    <span class="k">if</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;rate&#39;</span><span class="p">:</span>
        <span class="c1"># Use firing rate features</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">extract_rate_features</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">decoding_window</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
        <span class="c1"># Use temporal pattern features</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">extract_temporal_features</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">decoding_window</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;synchrony&#39;</span><span class="p">:</span>
        <span class="c1"># Use synchrony-based features</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">extract_synchrony_features</span><span class="p">(</span><span class="n">neural_data</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">decoding_window</span><span class="p">)</span>
    
    <span class="c1"># Select appropriate model based on hypothesis</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">accuracy</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">fit_linear_decoder</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">stimulus_conditions</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;nonlinear&#39;</span><span class="p">:</span>
        <span class="n">accuracy</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="n">fit_nonlinear_decoder</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">stimulus_conditions</span><span class="p">)</span>
    
    <span class="c1"># Test against specific prediction in hypothesis</span>
    <span class="n">predicted_accuracy</span> <span class="o">=</span> <span class="n">hypothesis</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;predicted_accuracy&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="n">statistical_test</span><span class="p">(</span><span class="n">accuracy</span><span class="p">,</span> <span class="n">predicted_accuracy</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;hypothesis_parameters&#39;</span><span class="p">:</span> <span class="n">hypothesis</span><span class="p">,</span>
        <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">accuracy</span><span class="p">,</span>
        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
        <span class="s1">&#39;model&#39;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>
        <span class="s1">&#39;conclusion&#39;</span><span class="p">:</span> <span class="s1">&#39;Supported&#39;</span> <span class="k">if</span> <span class="n">p_value</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="k">else</span> <span class="s1">&#39;Not supported&#39;</span>
    <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="the-future-of-neural-data-science-ai-augmented-programming">
<h3>8.7.3 The Future of Neural Data Science: AI-Augmented Programming<a class="headerlink" href="#the-future-of-neural-data-science-ai-augmented-programming" title="Link to this heading">#</a></h3>
<p><img alt="AI-Augmented Programming Workflow" src="../_images/ai_augmented_workflow.svg" />
<em>Figure 8.4: Evolution of neural data analysis workflows, contrasting traditional programming approaches with AI-augmented programming that enables neuroscientists to focus on scientific questions rather than implementation details.</em></p>
<p>The landscape of neural data analysis is rapidly evolving with the integration of AI assistants:</p>
<ol class="arabic simple">
<li><p><strong>From Syntax to Intent</strong>: Future programming will focus more on communicating analysis intent rather than syntax details.</p></li>
<li><p><strong>Agent-Assisted Workflows</strong>: AI agents will handle routine coding tasks, allowing neuroscientists to focus on experimental design and interpretation.</p></li>
<li><p><strong>Natural Language Data Exploration</strong>: Interactive exploration of datasets through natural language queries.</p></li>
<li><p><strong>Code Generation and Optimization</strong>: AI generating efficient, optimized code based on high-level descriptions of analysis goals.</p></li>
<li><p><strong>Democratized Analysis</strong>: Advanced analysis techniques becoming accessible to researchers without extensive programming backgrounds.</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example of a future AI-augmented neural analysis workflow</span>
<span class="c1"># The comments represent natural language instructions to an AI assistant</span>

<span class="c1"># &quot;Load the calcium imaging dataset and preprocess it using standard parameters&quot;</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">load_calcium_imaging_dataset</span><span class="p">(</span><span class="s1">&#39;experiment_20230512.h5&#39;</span><span class="p">)</span>
<span class="n">preprocessed_data</span> <span class="o">=</span> <span class="n">preprocess_calcium_data</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">raw_traces</span><span class="p">)</span>

<span class="c1"># &quot;Extract cell activity during the different experimental conditions&quot;</span>
<span class="n">cell_activity</span> <span class="o">=</span> <span class="n">extract_condition_specific_activity</span><span class="p">(</span>
    <span class="n">preprocessed_data</span><span class="p">,</span> 
    <span class="n">dataset</span><span class="o">.</span><span class="n">experiment_conditions</span>
<span class="p">)</span>

<span class="c1"># &quot;Find cells that show significant tuning to the target stimulus&quot;</span>
<span class="c1"># The AI would generate appropriate statistical testing code</span>
<span class="n">tuned_cells</span> <span class="o">=</span> <span class="n">find_significantly_tuned_cells</span><span class="p">(</span>
    <span class="n">cell_activity</span><span class="p">,</span>
    <span class="n">condition</span><span class="o">=</span><span class="s1">&#39;target_stimulus&#39;</span><span class="p">,</span>
    <span class="n">statistical_test</span><span class="o">=</span><span class="s1">&#39;permutation&#39;</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span>
<span class="p">)</span>

<span class="c1"># &quot;Visualize the spatial distribution of tuned cells&quot;</span>
<span class="c1"># The AI would generate appropriate visualization code</span>
<span class="n">spatial_map</span> <span class="o">=</span> <span class="n">plot_spatial_tuning_map</span><span class="p">(</span>
    <span class="n">tuned_cells</span><span class="p">,</span>
    <span class="n">dataset</span><span class="o">.</span><span class="n">cell_coordinates</span><span class="p">,</span>
    <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;heatmap&#39;</span>
<span class="p">)</span>

<span class="c1"># &quot;Create a model that predicts stimulus identity from population activity&quot;</span>
<span class="c1"># The AI would select an appropriate decoding approach based on data properties</span>
<span class="n">decoder_model</span> <span class="o">=</span> <span class="n">create_population_decoder</span><span class="p">(</span>
    <span class="n">cell_activity</span><span class="p">,</span>
    <span class="n">dataset</span><span class="o">.</span><span class="n">stimulus_conditions</span><span class="p">,</span>
    <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;optimal&#39;</span><span class="p">,</span>  <span class="c1"># AI selects appropriate model</span>
    <span class="n">cross_validation</span><span class="o">=</span><span class="s1">&#39;timeseries&#39;</span>  <span class="c1"># AI selects appropriate validation approach</span>
<span class="p">)</span>

<span class="c1"># &quot;Summarize the key findings in a publication-ready figure&quot;</span>
<span class="c1"># The AI would generate comprehensive figure code</span>
<span class="n">create_summary_figure</span><span class="p">(</span>
    <span class="n">tuned_cells</span><span class="o">=</span><span class="n">tuned_cells</span><span class="p">,</span>
    <span class="n">spatial_map</span><span class="o">=</span><span class="n">spatial_map</span><span class="p">,</span>
    <span class="n">decoder_performance</span><span class="o">=</span><span class="n">decoder_model</span><span class="o">.</span><span class="n">performance</span><span class="p">,</span>
    <span class="n">save_path</span><span class="o">=</span><span class="s1">&#39;figures/main_result.pdf&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This AI-augmented workflow illustrates how neuroscientists of the future will interact with data through higher-level conceptual instructions rather than detailed code implementation. The AI handles the translation from scientific intent to executable code, allowing researchers to focus on the scientific questions rather than programming details.</p>
</section>
<section id="best-practices-for-the-ai-assisted-neuroscience-era">
<h3>8.7.4 Best Practices for the AI-Assisted Neuroscience Era<a class="headerlink" href="#best-practices-for-the-ai-assisted-neuroscience-era" title="Link to this heading">#</a></h3>
<p>As we transition to AI-augmented neural data analysis, several best practices emerge:</p>
<ol class="arabic simple">
<li><p><strong>Focus on Scientific Questions</strong>: Clearly formulate scientific hypotheses and analysis goals rather than programming details.</p></li>
<li><p><strong>Conceptual Understanding</strong>: Maintain understanding of analysis principles, even when implementation details are handled by AI.</p></li>
<li><p><strong>Critical Evaluation</strong>: Carefully verify AI-generated analyses and visualizations for scientific validity.</p></li>
<li><p><strong>Documentation and Reproducibility</strong>: Ensure that analysis methods are thoroughly documented, including AI-generated components.</p></li>
<li><p><strong>Continuous Learning</strong>: Stay current with analytical approaches and methodologies to effectively guide AI tools.</p></li>
</ol>
<p>The future neuroscientist will be less a programmer and more an analytical strategist, guiding AI tools to efficiently transform data into insights.</p>
</section>
</section>
<section id="take-aways">
<h2>8.8 Take-aways<a class="headerlink" href="#take-aways" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p><strong>Domain-Specific Adaptations</strong>: Neural data requires specialized preprocessing and feature extraction techniques tailored to the specific data type (spikes, LFPs, EEG, etc.).</p></li>
<li><p><strong>Critical Preprocessing</strong>: Small changes in preprocessing parameters can dramatically affect results in neural data analysis, requiring careful validation and parameter selection.</p></li>
<li><p><strong>Feature Extraction Matters</strong>: The choice of features is crucial for neural data analysis, with frequency domain features often being particularly informative.</p></li>
<li><p><strong>Dimensionality Reduction</strong>: Neural datasets typically have high dimensionality, necessitating effective dimensionality reduction for visualization and modeling.</p></li>
<li><p><strong>Model Validation</strong>: Cross-validation in neural data analysis should account for temporal dependencies and non-stationarity.</p></li>
<li><p><strong>Encoding vs. Decoding</strong>: Both approaches provide complementary insights - encoding models predict neural responses to stimuli, while decoding models predict stimuli from neural activity.</p></li>
<li><p><strong>Reproducibility Challenges</strong>: Neural data analysis requires meticulous documentation of each processing step to ensure reproducibility.</p></li>
<li><p><strong>Python Ecosystem</strong>: Python’s rich ecosystem of libraries and tools makes it uniquely suited for neural data analysis.</p></li>
<li><p><strong>AI-Augmented Analysis</strong>: The future of neural data science involves AI assistants that handle routine coding tasks, allowing neuroscientists to focus on higher-level questions and interpretations.</p></li>
</ul>
</section>
<section id="further-reading-media">
<h2>8.9 Further Reading &amp; Media<a class="headerlink" href="#further-reading-media" title="Link to this heading">#</a></h2>
<section id="neuroscience-data-analysis">
<h3>Neuroscience Data Analysis<a class="headerlink" href="#neuroscience-data-analysis" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Kriegeskorte, N., &amp; Golan, T. (2019). “Neural network models and deep learning”. <em>Current Biology</em>, 29(7), R231-R236.</p></li>
<li><p>Paninski, L., &amp; Cunningham, J. P. (2018). “Neural data science: accelerating the experiment-analysis-theory cycle in large-scale neuroscience”. <em>Current Opinion in Neurobiology</em>, 50, 232-241.</p></li>
<li><p>Glaser, J. I., Benjamin, A. S., Farhoodi, R., &amp; Kording, K. P. (2019). “The roles of supervised machine learning in systems neuroscience”. <em>Progress in Neurobiology</em>, 175, 126-137.</p></li>
<li><p>Harris, K. D., Quiroga, R. Q., Freeman, J., &amp; Smith, S. L. (2016). “Improving data quality in neuronal population recordings”. <em>Nature Neuroscience</em>, 19(9), 1165-1174.</p></li>
<li><p>Vyas, S., Golub, M.D., Sussillo, D., &amp; Shenoy, K.V. (2020). “Computation Through Neural Population Dynamics”. <em>Annual Review of Neuroscience</em>, 43, 249-275.</p></li>
<li><p>Kobak, D., &amp; Berens, P. (2019). “The art of using t-SNE for single-cell transcriptomics”. <em>Nature Communications</em>, 10(1), 1-14.</p></li>
<li><p>Pachitariu, M., &amp; Sahani, M. (2012). “Learning visual motion in recurrent neural networks”. <em>Advances in Neural Information Processing Systems</em>, 25, 1322-1330.</p></li>
</ul>
</section>
<section id="python-for-scientific-computing">
<h3>Python for Scientific Computing<a class="headerlink" href="#python-for-scientific-computing" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>VanderPlas, J. (2016). <em>A Whirlwind Tour of Python</em>. O’Reilly Media.</p></li>
<li><p>McKinney, W. (2017). <em>Python for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython</em>. O’Reilly Media.</p></li>
<li><p>Raschka, S., &amp; Mirjalili, V. (2019). <em>Python Machine Learning: Machine Learning and Deep Learning with Python, scikit-learn, and TensorFlow 2</em>. Packt Publishing.</p></li>
<li><p>Géron, A. (2019). <em>Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow: Concepts, Tools, and Techniques to Build Intelligent Systems</em>. O’Reilly Media.</p></li>
</ul>
</section>
<section id="ai-augmented-programming">
<h3>AI-Augmented Programming<a class="headerlink" href="#ai-augmented-programming" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Bubeck, S., Chandrasekaran, V., Eldan, R., Gehrke, J., Horvitz, E., Kamar, E., Lee, P., Lee, Y.T., Li, Y., Lundberg, S. and Nori, H. (2023). “Sparks of Artificial General Intelligence: Early experiments with GPT-4”. arXiv preprint arXiv:2303.12712.</p></li>
<li><p>Chen, M., Tworek, J., Jun, H., Yuan, Q., Pinto, H.P.D.O., Kaplan, J., Edwards, H., Burda, Y., Joseph, N., Brockman, G. and Ray, A. (2021). “Evaluating large language models trained on code”. arXiv preprint arXiv:2107.03374.</p></li>
<li><p>Shen, S., Amer, M., Bender, G., Ramachandran, P., &amp; Shlens, J. (2023). “Augmenting Developers with Large Language Models: The Impact of Code Suggestions on Productivity, Code Quality, and Well-being at Microsoft”. arXiv preprint arXiv:2309.11436.</p></li>
<li><p>Bricken, T., Elhage, N., Vance, N., Nanda, N., Edwards, B., Steinhardt, J., &amp; Bowman, S. R. (2023). “Towards understanding the behavior of neural algorithms”. arXiv preprint arXiv:2305.18465.</p></li>
<li><p>Shanahan, M. (2022). “Talking about large language models”. arXiv preprint arXiv:2212.03551.</p></li>
</ul>
</section>
<section id="future-of-neuroscience-and-ai">
<h3>Future of Neuroscience and AI<a class="headerlink" href="#future-of-neuroscience-and-ai" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Richards, B.A., Lillicrap, T.P., Beaudoin, P., Bengio, Y., Bogacz, R., Christensen, A., Clopath, C., Costa, R.P., de Berker, A., Ganguli, S. and Gillon, C.J. (2019). “A deep learning framework for neuroscience”. <em>Nature Neuroscience</em>, 22(11), 1761-1770.</p></li>
<li><p>Zador, A. M. (2019). “A critique of pure learning and what artificial neural networks can learn from animal brains”. <em>Nature Communications</em>, 10(1), 1-7.</p></li>
<li><p>Jonas, E., &amp; Kording, K. P. (2017). “Could a neuroscientist understand a microprocessor?”. <em>PLoS computational biology</em>, 13(1), e1005268.</p></li>
<li><p>Marblestone, A. H., Wayne, G., &amp; Kording, K. P. (2016). “Toward an integration of deep learning and neuroscience”. <em>Frontiers in computational neuroscience</em>, 10, 94.</p></li>
<li><p>Kording, K. P., Benjamin, A. S., Farhoodi, R., &amp; Glaser, J. I. (2020). “The roles of machine learning in biomedical science”. <em>Nature Machine Intelligence</em>, 2(4), 198-204.</p></li>
</ul>
</section>
<section id="recommended-tools-and-libraries">
<h3>Recommended Tools and Libraries<a class="headerlink" href="#recommended-tools-and-libraries" title="Link to this heading">#</a></h3>
<section id="id1">
<h4>Neuroscience Data Analysis<a class="headerlink" href="#id1" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p><strong>MNE-Python</strong>: Comprehensive toolkit for processing electrophysiological data</p></li>
<li><p><strong>Neo</strong>: Python package for handling electrophysiology data in Python</p></li>
<li><p><strong>Elephant</strong>: Analysis library for neurophysiology data</p></li>
<li><p><strong>CaImAn</strong>: Calcium Imaging Analysis package</p></li>
<li><p><strong>SpikeInterface</strong>: Framework for spike sorting and electrophysiology analysis</p></li>
<li><p><strong>NWB (Neurodata Without Borders)</strong>: Standard format for neurophysiology data</p></li>
<li><p><strong>DeepLabCut</strong>: Deep learning for markerless pose estimation</p></li>
<li><p><strong>CellProfiler</strong>: Cell image analysis software</p></li>
<li><p><strong>BrainGlobe</strong>: Tools for brain atlas visualization and anatomical analysis</p></li>
</ul>
</section>
<section id="ai-assisted-programming">
<h4>AI-Assisted Programming<a class="headerlink" href="#ai-assisted-programming" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p><strong>GitHub Copilot</strong>: AI pair programmer that offers code suggestions</p></li>
<li><p><strong>Jupyter AI</strong>: AI extensions for Jupyter notebooks</p></li>
<li><p><strong>LangChain</strong>: Framework for developing applications powered by language models</p></li>
<li><p><strong>Gradio</strong>: Tool for quickly creating UIs for machine learning models</p></li>
<li><p><strong>Streamlit</strong>: App framework for machine learning and data science</p></li>
<li><p><strong>Hugging Face Transformers</strong>: State-of-the-art NLP models for code generation</p></li>
<li><p><strong>AutoML</strong>: Automated machine learning platforms for model selection and hyperparameter tuning</p></li>
</ul>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "executablebooks/jupyter-book",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./part2"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ch07_information_theory.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 7: Information Theory Essentials</p>
      </div>
    </a>
    <a class="right-next"
       href="../part3/ch09_ml_foundations.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 9: Classical Machine-Learning Foundations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chapter-goals">8.0 Chapter Goals</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#neural-data-types-sources">8.1 Neural Data Types &amp; Sources</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#spike-trains-and-local-field-potentials-lfps">8.1.1 Spike Trains and Local Field Potentials (LFPs)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eeg-meg-and-fmri-data">8.1.2 EEG, MEG, and fMRI Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#calcium-imaging">8.1.3 Calcium Imaging</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#behavioral-measurements">8.1.4 Behavioral Measurements</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#data-preprocessing">8.2 Data Preprocessing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#filtering-and-artifact-removal">8.2.1 Filtering and Artifact Removal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensionality-reduction-techniques">8.2.2 Dimensionality Reduction Techniques</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#feature-extraction">8.2.3 Feature Extraction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#normalization-approaches">8.2.4 Normalization Approaches</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exploratory-analysis">8.3 Exploratory Analysis</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#descriptive-statistics-for-neural-data">8.3.1 Descriptive Statistics for Neural Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization-techniques">8.3.2 Visualization Techniques</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dimensionality-reduction-and-visualization">8.3.3 Dimensionality Reduction and Visualization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#time-frequency-analysis">8.3.4 Time-Frequency Analysis</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#statistical-modeling">8.4 Statistical Modeling</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#generalized-linear-models-for-neural-data">8.4.1 Generalized Linear Models for Neural Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#point-process-models-for-spike-trains">8.4.2 Point Process Models for Spike Trains</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bayesian-approaches">8.4.3 Bayesian Approaches</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model-validation-techniques">8.4.4 Model Validation Techniques</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#machine-learning-applications">8.5 Machine Learning Applications</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#supervised-learning-for-neural-decoding">8.5.1 Supervised Learning for Neural Decoding</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unsupervised-learning-for-pattern-discovery">8.5.2 Unsupervised Learning for Pattern Discovery</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#deep-learning-approaches-for-neural-data">8.5.3 Deep Learning Approaches for Neural Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#transfer-learning-and-domain-adaptation">8.5.4 Transfer Learning and Domain Adaptation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#code-lab-building-an-end-to-end-pipeline">8.6 Code Lab: Building an End-to-End Pipeline</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-art-of-programming-for-neuroscience-data">8.7 The Art of Programming for Neuroscience Data</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-python-for-neural-data-analysis">8.7.1 Why Python for Neural Data Analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#from-code-to-concept-programming-as-scientific-thinking">8.7.2 From Code to Concept: Programming as Scientific Thinking</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-future-of-neural-data-science-ai-augmented-programming">8.7.3 The Future of Neural Data Science: AI-Augmented Programming</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#best-practices-for-the-ai-assisted-neuroscience-era">8.7.4 Best Practices for the AI-Assisted Neuroscience Era</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#take-aways">8.8 Take-aways</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading-media">8.9 Further Reading &amp; Media</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#neuroscience-data-analysis">Neuroscience Data Analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#python-for-scientific-computing">Python for Scientific Computing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ai-augmented-programming">AI-Augmented Programming</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#future-of-neuroscience-and-ai">Future of Neuroscience and AI</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recommended-tools-and-libraries">Recommended Tools and Libraries</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Neuroscience Data Analysis</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ai-assisted-programming">AI-Assisted Programming</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Richard Young
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>